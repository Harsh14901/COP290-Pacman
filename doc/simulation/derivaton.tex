\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{multirow}


\title{Reading By Visualisation Derivation}
\author{Harsh Aggarwal, Pranjal Aggarwal}
% \date{cs5190443@iitd.ac.in}
\date{}

\usepackage{natbib}
\usepackage{graphicx}
\usepackage[center]{caption}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[margin=1.2in]{geometry}
\usepackage{breqn}
\usepackage{siunitx}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage[colorlinks=true,linkcolor=blue]{hyperref}


\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\newcommand{\Ait}{\ensuremath{A_{i \rightarrow t}}}
\newcommand{\Ati}{\ensuremath{A_{t \rightarrow i}}}
\newcommand{\Adti}{\ensuremath{\Ati'}}
\newcommand{\Adit}{\ensuremath{\Ait'}}

\newcommand{\Eti}{\ensuremath{E_{t \rightarrow i}}}
\newcommand{\Dti}{\ensuremath{D_{t \rightarrow i}}}
\newcommand{\Dit}{\ensuremath{D_{i \rightarrow t}}}

\newcommand{\Dtr}{\ensuremath{D^{(tr)}}}
\newcommand{\Dval}{\ensuremath{D^{(val)}}}

\newcommand{\ToA}{\ensuremath{T(\Ati, \Ait)}}
\newcommand{\TsoA}{\ensuremath{T^*(\Ati, \Ait)}}
\newcommand{\TdoA}{\ensuremath{T'(\Ati, \Ait)}}
\newcommand{\TPlus}{\ensuremath{T^+}}
\newcommand{\TMinus}{\ensuremath{T^-}}

\newcommand{\Ov}{\ensuremath{O_{i \rightarrow t}}}
\newcommand{\OoA}{\ensuremath{\Ov(\Ait)}}
\newcommand{\OsoA}{\ensuremath{\Ov^*(\Ait)}}
\newcommand{\OdoA}{\ensuremath{\Ov'(\Ait)}}
\newcommand{\OPlus}{\ensuremath{\Ov^+}}
\newcommand{\OMinus}{\ensuremath{\Ov^-}}

\newcommand{\Pv}{\ensuremath{P_{i \rightarrow t}}}
\newcommand{\PoA}{\ensuremath{\Pv(\Ait)}}
\newcommand{\PsoA}{\ensuremath{\Pv^*(\Ait)}}
\newcommand{\PdoA}{\ensuremath{\Pv'(\Ait)}}
\newcommand{\PPlus}{\ensuremath{\Pv^+}}
\newcommand{\PMinus}{\ensuremath{\Pv^-}}

\newcommand{\Gv}{\ensuremath{G_{t \rightarrow i}}}
\newcommand{\GoA}{\ensuremath{\Gv(\Ati)}}
\newcommand{\GsoA}{\ensuremath{\Gv^*(\Ati)}}
\newcommand{\GdoA}{\ensuremath{\Gv'(\Ati)}}
\newcommand{\GPlus}{\ensuremath{\Gv^+}}
\newcommand{\GMinus}{\ensuremath{\Gv^-}}

\begin{document}

\maketitle

\section{Introduction}

% Start of with something else, these points may come in doc but not here, as they are not directly relevant to our problem
With advent of modern technology, once a thing of future, is now becoming a common reality. However AI agents employed
in these systems have to face various challanges, as the cognitive abilities of AI is far less than that of humans. 
One such task is that of robot cleaning. The robot systems employed in this task have to sense the enviornment
and take decisions without harming the humans or other objects. At the same time these systems should be efficient enough to complete their task in
a limited time and also in limited amount of energy. In this report we study this problem of efficiency, and discuss various literature, which have tried to solve a problem similar to this.
We use them and build upon a new heuristic based approach.

\section{Problem Statement}

Suppose we have an indoor building with n rooms, which need to be cleaned. Each room may have different sizes
and floorplans, and different amount of dust in them. The task of the robot is to clean all the rooms in the building in a limited amount of time.

% This point  can be further elaborated
[This can be due to both limited battery capacity of robot or urgency to complete the tasl ]

At the same the robot has to maximise the amount of cumulative amount of dust cleaned in all rooms, while providing a minimum in each of the room.
The problem can be modelled as a two stage problem:
\begin{itemize}
    \item In the first stage, we find the best path for the robot to reach all the rooms. This is a Travelling Salesman Problem we propose Steiner TSP Algorithm for this.
    \item In the second stage, we allot a certain time to each room based on their size, and the robot has to find a path which maximizes the dust cleaned, while at the same time is within the alloted budget of time.
\end{itemize}

Both of these stages can be modelled as a path finding in graph problem, where in first stage the pathway connecting rooms is equivalent to edges and the rooms as vertices.
For the second stage we divide a room into a grid of n*n cells, each either being occupied by an object, or having certain amount of dust. This grid can be considered as graph,
with the unoccupied cells as the vertices and the amount of dust in them as their vertex value. Since it will take slightly more time for robot to clean cells with larger dust amount,
the edge lengths will be dependent on the values of both the connected vertices:
\begin{equation}
    C_{i,j} = k + f(V_i,V_j)
\end{equation}
Where k is a constant value dependent on the speed of robot, and f is an arbitary function defined on the ordered values of two vertices.



% % \begin{align*}
% \begin{equation} \label{eq:1}
%     min_{\Ati , \Ait} \; \;  L(\TsoA, \Dval)   
% \end{equation}
%     \[ s.t. \]
% \begin{equation}  \label{eq:2}
%     \TsoA = min_T L(T,\Dtr) + \gamma L(\Dtr,T,\OsoA,\PsoA,\GsoA)   
% \end{equation}
% \begin{equation}  \label{eq:3}
%     \OsoA,\PsoA = min_{\Ov,\Pv} L(\Ait , \Ov, \Pv , \Gv) \\
% \end{equation}
% \begin{equation} \label{eq:4}
%     \GsoA = max_{\Gv} min_{\Eti} L(\Ait, \Gv, \Eti , \Dti) 
% \end{equation}

\section{Related Work}

The problem at hand can be modelled as a variant of TSP known as Profit-TSP. In this problem,
the Salesman has to maximise its profits however in a fixed finite amount of time. 
This has been shown to an NP-Hard Problem \cite{ref1}. 

% TODO: Complete This

\section{Solution}

In this section we will discuss two possible heuristic solutions to our problem. 

\subsection{Centre of Gravity Based Algorithm}

% Cite the Paper and write the content

\subsection{Multi-Stage Algorithm}

% Check This
While the previous algorithm requires an Euclidean cost function, in this algorithm we will model a genric enough cost function and solve the problem.

We divide the solution to the problem in multiple stages each performing a different operation. All these stages are iterated over for multiple rounds, till convergence criteria is not met.
We use 4 different hyperparameters:- % Describe them

\subsubsection{Stage I: Insertion Stage}

At the start of stage we assume that we have a path $\{P(i) : 0<i \leq k\}$, where k is the path length, and P(i) denotes the $i^{th}$ vertex in the path.
Since we have to start and end at the same position,
$P(1),P(2) = 1$.
We define two sets $\Psi$ and $\Omega$
 , which contains the vertices in current path and and vertices not in current path respectively.
Now we first decide, a vertex to insert, lets call it $j$. Now we need to find a point in the path where we can insert the given vertex, and which gives maximum increase in profit while minimising the cost.
Then point of insertion can be found by solving the following Optimisation:

\begin{equation} \label{eq2}
   \Theta_{j} min_{i = 1,\dots,k} ( C_{V(i),j} + C_{j,V(i+1)} - C_{V(i),V(i-1)} )
\end{equation}
Where $\Theta_{j}$ is the calculated cost of given vertex for insertion.
Also note that in \refeq{eq2} we only need to iterate over only neigbours of vertex j, which in our case can be a maximum of 8, and therefore step 1 can be done in O(1) time.

Now we iterate over all the sutiable vertices for insertions, i.e and calculate the corresponding
$\Theta_{j}$. Now the best vertex is the one which give the maximum profit while with minimum cost. 
Therefore we have to solve the following equation:
\begin{equation} \label{eq3}
    max_{j \in \Omega} \frac{P(j)}{C(j)} )
\end{equation}

However this would give high weightage to high density vertices therefore we add an additional hyperparameter $\lambda_1$ in \refeq{eq3},
and modify it as:

\begin{equation} \label{eq4}
    max_{j \in \Omega}  \frac{P(j)^{\lambda_{1}}}{C(j)} 
\end{equation}

We hypothesize that $\lambda_{1} < 1$. This is due the fact that a minimum time is always required for robot to cross a cell, and thus by adding this additional hyperparameter,
we ensure that portions of small dust are not leftover.

We continue this process of insertion till the cost doesnt exceed $\lambda_{2,1} \beta$, where $\lambda_{2,k}$ is another hyperparameter whose value varies in different rounds, and always increasing in subsequent rounds. 
If addition of any vertex increases the cost beyound alloted capacity, we omit it and move on to the next stage.








\subsubsection{Final Algorithm}

\begin{algorithm}[H]
    \SetAlgoLined
     \While{not converged}{
      1. Stage 1 \;
      2. Stage 2 \;
      3. Stage 3 \;
     }
\caption{Optimisation Algorithm}
\end{algorithm}

\section{Computation and Results}

% Write down about the simulation here


\section{Conclusion}

% Write down inference and also future directions

\bibliographystyle{plain}
\bibliography{sample}


\end{document}
